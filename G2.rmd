---
title: "IGHV1-2"
output:
  html_document:
    toc: true
    toc_float: true
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = F, error=F, message = F)
options(repos = BiocManager::repositories())
pacman::p_load('dplyr', 'tidyr', 'htmltools', 'bbplot',
               'ggplot2', 'rdrop2', 'shiny', 'BiocManager',
               'dendextend', 'data.table', 'Biostrings', 'alakazam', "unikn", 
               'plotly', 'ggdendro', "RColorBrewer", install = F)
```

```{r}
source("functions.R")
```

```{r, echo=FALSE}
load("data.rda")

chain = "IGH"
func <-  data.frame(allele = names(vgerms[[chain]]), functionality = !grepl("(ORF|P)",sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4])), sign = sapply(seqinr::getAnnot(vgerms_full[[chain]]), function(x) unlist(strsplit(x,"[|]"))[4]), stringsAsFactors = F)

mat <- mat_list$IGH$functional$nonsingle$all$`318`

load("data_frac_new2.rda")
data <- setDT(data_frac$IGH$functional$nonsingle$all$`318`$complete$`95`)
data[,v_call:=paste0(v_gene,"*",v_allele)]
load("alleles_dbs.rda")
allele_db <- alleles_dbs$IGH$functional$nonsingle$all$`318`$complete$`95`
allele_db <- allele_db %>% rowwise() %>% mutate(gene = getGene(or_allele, strip_d = F, omit_nl = F), group = strsplit(gsub(gene, "", new_allele),"[*]")[[1]][1], gene_group = getGene(new_allele, strip_d = F, omit_nl = F))
load("functional_groups.rda")
func_groups <- functional_groups$IGH$functional$nonsingle$all$`318`$complete$`95`

cols <- c("#FAAB18", "#1380A1","#990000", "#588300")

pal <- cols %>% 
  newpal(names = c("orangy", "bluish", "redish", "greeny"))

```

```{r,echo=FALSE}
g = "IGHV1-2"
gr <- allele_db %>% filter(gene == g) %>% pull(group) %>% unique()
g_group <- allele_db %>% filter(gene == g) %>% pull(gene_group) %>% unique()
```

## Allele appearnce 

The group of IGHV1-2 includes `r sum(grepl(paste0(g,"[*]"), func$allele))` alleles, `r sum(func$functionality[grepl(paste0(g,"[*]"), func$allele)])` out of the alleles are functional.

For each allele we counted the number of appearances across the population, any appearance was considered valid. 

```{r}

ggplot(data[grepl(g_group,v_gene)], aes(v_allele, fill = v_allele)) + geom_bar() + facet_grid(.~project) + labs(x = "allele", y = "# Individuals", fill = "") + 
  bbplot::bbc_style()  + theme(legend.position = "none") + scale_fill_manual(values = pal %>% usecol(n = 10))
```

## Group alignment

Based on the viewd alleles, we calculated the distance between the germline sequences.

```{r, fig.width=18,fig.height=30}
v_calls <- unique(data[grepl(g_group,v_gene),v_call])
seq_align(v_calls, allele_db, vgerms, chain, mat, g_group)
```

## Sequence depth

To examine the potential cutoff we observed the sequence depth for each allele

```{r}
ggplot(data[grepl(g_group,v_gene)], aes(v_allele, count, color = project)) + 
  geom_boxplot(outlier.shape=NA) +
  geom_point(position=position_jitterdodge(jitter.width = 0.1)) + 
  labs(x = "allele", y = "# Sequences", color = "") + 
  bbplot::bbc_style() + scale_color_manual(values = pal %>% usecol(n = 10))
```

## 0.5% cutoff 

We set an initial cutoff of $0.5\%$ to determine the potential genotype priors. For this cutoff we examined the zygousity state, such as homozygousity, heterozygousity and so on.


```{r}

tmp_allele_db <-
  allele_db %>% filter(grepl(func_groups[as.character(g)], new_allele)) %>%
  dplyr::group_by(new_allele) %>% dplyr::summarise(or_allele = paste0(or_allele, collapse = "/"))

or_allele <-
  setNames(gsub(chain, "", as.character(tmp_allele_db$or_allele)), as.character(gsub(
    paste0(func_groups[as.character(g)], "[*]"),
    "",
    tmp_allele_db$new_allele
  )))

allele_thresh = 0.5

tmp <- data_cutoff(data, func_groups, g, allele_thresh, or_allele)

```

With the selected cutoff we saw that there are `r length(unique(tmp %>% arrange(zygousity_state) %>% pull(zygousity_state)))` zygousity states.

```{r, warning = F, error=F, message = F}
p_list <- c()
for(i in as.character(unique(tmp %>% dplyr::arrange(zygousity_state) %>% dplyr::pull(zygousity_state)))){
  p_list[[i]] <- plot_zygousity(tmp, i, allele_thresh, g) %>% config(edits = list(shapePosition = TRUE),
                    scrollZoom = FALSE) %>% layout(title = paste0("state ", i))
  #
}

tagList(p_list)
```

## Observations

This section is editable by clicking on the edit button below. To refresh the section click on the refresh button

```{r, message=F, echo=F, warning=F}
# Authenticate and save token for later use2
token <- drop_auth(rdstoken = "dropbox_token.rds")

# Retrieveing your file is as simple as
drop_download("public/conclusions/IGHV1-2.docx", local_path = "./IGHV1-2.docx",
              overwrite = TRUE, verbose = F)
drop_df <- textreadr::read_docx("./IGHV1-2.docx")
invisible(rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), verbose = FALSE))

ui <- fluidPage(

    # Application title
    mainPanel(
      shiny::actionButton(inputId='ab1', label="Edit text", 
                          icon = icon("edit"), 
                          onclick ="window.open('https://www.dropbox.com/scl/fi/crphl3u49fmkw8wnb5v71/IGHV1-2.docx?dl=0&rlkey=l54oqhrlxx8wyp6bywr224sx0')"),
      
      shiny::actionButton(inputId='ab2', label="Reload text", 
                          icon = icon("sync-alt")),
      
      #htmlOutput("df_output"),
      uiOutput('markdown')
    )
)

server <- function(input, output) {
    
  observeEvent(input$ab2, {
    drop_download("public/conclusions/IGHV1-2.docx", local_path = "./IGHV1-2.docx",
              overwrite = TRUE, verbose = F)
    #drop_df <- textreadr::read_docx("./IGHV1-2.docx")
    
    rmarkdown::pandoc_convert(input = "IGHV1-2.docx", to = "markdown", output = "IGHV1-2_docx.md", options = c("--wrap=none","--reference-links","--metadata-file=metadata.yaml","--standalone"), verbose = F)
    output$markdown <- renderUI({
      withMathJax(includeMarkdown(knitr::knit('IGHV1-2_docx.md', quiet = TRUE)))
    #HTML(markdown::markdownToHTML(knitr::knit('IGHV1-2_docx.Rmd', quiet = TRUE)))
  })
    
  })
    
  # output$df_output <- renderUI({
  #       if(input$ab2) return()
  #       HTML(paste(drop_df, collapse = "<br/><br/>"))
  #   })
  
  output$markdown <- renderUI({
    withMathJax(includeMarkdown(knitr::knit('./IGHV1-2_docx.md', quiet = TRUE)))
    #HTML(markdown::markdownToHTML(knitr::knit('IGHV1-2_docx.Rmd', quiet = TRUE)))
  })
}

shinyApp(ui = ui, server = server)

```

## Conclusions

From the results we belive that the cutoff for this group should be closer to $2\%$, and for the adjusted states the allele combinations and the relations are stated in the table below.

```{r}

tableData <- data_cutoff(data, func_groups, g, 2, or_allele) %>% dplyr::group_by(zygousity_state, v_alleles_abc, v_allele) %>% dplyr::summarise(mean_freq = IQR(freq)) %>% dplyr::group_by(zygousity_state, v_alleles_abc) %>% dplyr::summarise(fractions = paste0(round(mean_freq, 3), collapse = ";"))

DT::datatable(
        tableData,
        options = list(dom = "tipr"),
        selection = 'none',
        colnames = c(
          "Zygousity state" = "zygousity_state",
          "V\nallele" = "v_alleles_abc",
          "IQR fraction" = "fractions"
        )
      )

```

For interactive play on the threshold and relative allele fractions, please refer to [this site](https://peresay.shinyapps.io/cluster_app/?url=%22page_allele%22&func_group=%22IGHV1-2%22&allele_thresh=%222%22)
